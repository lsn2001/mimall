1-1 项目导读{ 商城页面流程 登录》产品首页》产品站》产品详情》购物车》订单确认》订单支付(微信/支付宝)》订单列表 业务开发流程 需求整理》UI设计》接口规范对接》搭建前端架构开发电商页面》微信/支付宝对接》线上部署

项目技术: 商城内容{ 页面{ 商城首页 登录 商城产品站 商城详情 购物车 订单确认 订单支付(微信/支付宝) 订单列表 } 组件系统{ NavHeader(导航组件) NavFooter(底部组件) ServiceBar(服务条组件) ProductParam(产品参数组件) OrderHeader(订单头部组件) Loading(加载组件) Modal(弹框组件) NoData(无数据组件) ScanPayCode(支付组件) }}


1、node版本 查询 node -v 
linux安装 tar -xvf解压后缀为.tar.xz
2-1 Git安装 { 查找Git which -a git 查看Git版本 git -version}
环境变量配置、开发工具配置 
存储密码-SSH添加公钥
团队使用Git命令开发项目

2-2 Git配置{ vscode 首选项》设置》setting.json 》"git.path":"/usr/local/bin/git 查看配置 git config --list 全局配置--global git configg --global user.name "jackbean" git config --global user.email "jackbean@51puise.com" 信任账号凭证 git config --global credential.helper Store 配置公钥 ssh-keygen -t rsa -C "youremail@example.com" 克隆项目 git clone 在git配置好SSH之后 每次提交就不用输入账号和密码了

2-5 Git指令 
git rm 文件名 (删除文件)
git branch 分支名 （创建分支 分支名后加 -d 分支名 是删除该分支） 
git checkout 分支名 （切换到分支上）
touch 文件名 （创建文件）
git status（查看状态）
git add 文件名 （在分支上添加文件 git add . 是新增所有）
git commit -m 备注 add 文件名 （提交文件 -m后接备注 加-a可全部提交）
git push 分支名（推送分支）
git mv <old> <new> （文件改名）
git tag t1.0.0 (创建标签)   git push t1.0.0 (推送标签)  git tag -d t1.0.0 (删除标签) git push origin :t1.0.0 (删除标签)
git merge 需要合并的分支名称 (将当前分支与需要合并的分支合并起来)
git checkout 文件名 (撤销修改后的代码回到修改前)
git reserve 需要回退的版本 (撤销指定版本的提交 指定的版本是你修改日志里修改后的代码 撤销是把修改过的代码回退到没修改代码时 会返回一个新版本号)
git reset 需要回退的版本 (撤销指定版本的提交 连历史记录都会撤销 reserve不会撤销历史记录，而且reserve还会返回一个新版本号)

3-1 Vue-cli4.0安装  Vue-cli脚手架是一个插件 自动帮我们集成webpack 帮我们构建、打包、编译，包括一些基本的架子 比如入口的JS、vue单页面的应用程序 我们只需要插入一些页面、一些路由就可以将项目跑起来
{ npm install -g @vue/cli(vue-cli是插件 一般都会发布在npm中) 》vue --verson(查看vue-cli的版本) 》which -a vue (查看vue位置) 》}

3-2 Vue-cli4.0使用
{vue create 项目名(创建项目) 》 cd 项目名 》 npm serve 项目(运行项目) 》 vue ui (打开Vue-cli内置的UI)}  
node_modules模块非常大，需要添加一个.gitignore忽略它，防止node_modules提交到git上
eslint会检查我们的代码 

4-1 CORS跨域
跨域是浏览器为了安全而做出的限制策略，防止有人随意篡改和抓取数据
浏览器请求必须遵循同源策略：同协议，同域名，同端口
CORS跨域 {服务端设置，前端直接调用，只需要后端允许前端某个站点访问 axios是promise结构，用then链式调用}  安装axios插件{npm i axios --save-dev 下载axios插件并保存到开发环境里面 }

4-2 JSONP跨域 
{安装jsonp插件 npm install jsonp --save-dev 》 不是XHR请求而是一个JS脚本 》 json(url,(err,res)={}) 第一个参数是url，第二个是options配置，第三个是回调函数 回调函数的第一个参数是err错误信息，第二个参数是res返回结果  }

4-3 接口代理
接口代理：通过修改nginx服务器配置来实现，只需前端修改，后台不动   效果:访问的是自己的接口,但是内部会通过node.js转发别人的服务
需要webpack进行编译，解析端口代理
创建vue.config.js文件 》
module.exports = {
    devServer:{
        host:'localhost', // 域名
        port:'8080', // 端口
        // 代理 访问/api接口 实际上访问到了target所设置的地址
        proxy:{
            // 如果有很多种接口 我们需要设置很多个接口的拦截设置，但是我们在这些接口的前面加多一个/api路径，这只是一个虚拟的路径，这样所有的接口都可以统一被转发
            'api':{
                // 实际访问的地址
                target:'https://www.imooc.com',
                // 是否将主机头/api设置成原点
                changeOrigin:true,
                // 当拦截到/api时，将/api设置为空，这样只会转发/api后面的接口路径 然后拼接到target目标地址的后面 实现了所有接口的统一转发
                pathRewrite:{
                    '/api':''
                }
            }
        }
    }
} 



4-4 需求梳理{ 熟悉文档、查看原型、读懂需求 》 了解前端设计稿 》 设计前端业务架构 》 了解后台接口文档 》 指定相关对接规范 》 协调资源(素材、人员、图片资源) 》搭建前端框架 } 

4-5 {App.vue根组件 不用做处理 只需要放入<router-view> 它能够加载子页面，嵌套其它组件 }

4-6 基本插件{ vue-lazyload element-ui node-sass sass-loader vue-awesome-swiper vue-axios vue-cookie 前后端交互 用cookie传递}

4-7 路由封装
import Vue from 'vue' 和 import Router from 'vue-router' 导入vue和vue-router 》Vue.use(Router)加载插件 》将NavHeader和NavFooter封到Home中 将index product detail划分为home的子路由 将orderList orderConfirm orderPay alipay划分为order的子路由 》在main.js中加载路由 》 import router from './router' 》在new Vue中加载router实例，当key和value都一样时，可以省略value值，比如导入的名字是routers 则需要写成router:routers} 

// 导出Router
export default new Router({
    // 配置路由列表和子路由
    route:[
        {
            path:'/',
            // 加载home组件(加载前都需要先import Home from 'home'导入组件) name是指文件名 节省每个页面都导入Nav-Header和Nav-Footer 所以定义一个home父路由
            name:'home',
            // 组件名
            component:Home,
            // 路由重定向 默认跳到这个地址
            redirect:'/index'
            // 定义子路由
            children:[
                {
                    path:'index'
                }
            ]
        }
    ]
}); 


4-8 Storage封装
Cookie，localStorage，sessionStorage区别:
储存大小：Cookie4k,Storage5M 
有效期: Cookie拥有有效期，Stroage永久储存(只有localStorage是本地永久存储) Cookie会发送到服务端，储存在内存中，Storage只储存在浏览器端 (sessionStorage是存储到内存里的)
路径:Cookie有路径限制，Storage只储存在域名下 
API：Cookie没有特定的API,Storage有对应的API
sessionStorage会随着浏览器的关闭而关闭，localStorage不会

为什么要封装Storage？
1、Storage本身有API，但是只是简单的key/value形式
2、Storage只存储字符串，需要手工转换成json对象
3、Storage只能一次性清空，不能单个清空(API的方式)

Storage封装
// 项目里面用的文件 使用的是ES6的语法
const STORAGE_KEY = 'mall'
export default{
    // 存储值
    setItem(key,value,module_name){
        // 如果模块名存在 则先获取模块名下的某一属性 将value赋值给val[key] 再将val的值，存储到module_name中
        // 例如调用 setItem("age","18",user) 将"age":18存储在user这个模块当中 
        // 首先会调用getItem(user) 获取到user对象 将age加入到user模块中，并将age的值赋值为value的值18
        if(module_name){
            let val = this.getItem(module_name);
            val[key] = value;
            this.setItem(module_name,val)
        }
        else{
            // 在当前模块存储值，例如存储与user同级的数据
            let val = this.getStorage();
            val[key] = value;
            window.sessionStorage.setItem(STORAGE_KEY, JSON.stringify(val));
        }
    },
    // 获取某一个模块下面的属性的信息 例如:{user:{"username":"jack"}} 可以获取到username的信息
    getItem(key,module_name){
        if(module_name){
            // 递归调用 获取某一模块中的某一属性的信息
            let val = this.getItem(module_name);
            if(val){
                return val[key];
            }
        }
        // 先获取Storage信息，再获取Storage信息下的key的信息
        return this.getStorage()[key]
    },
    // 获取整个数据
    getStorage(){
        // JSON.parse将数据转换成JSON格式，通过window.sessionStorage.getItem()这个API获取Storage数据 第一个参数为key
        // 获取的数据要注意是JSON格式 key的值需要加上双引号 
        // 如果获取的Storage为空 则返回一个 object对象
        return JSON.parse(window.sessionStorage.getItem(STORAGE_KEY) || '{}');
    },
    // 清空(可单个清空)
    clear(key, module_name){
        let val = this.getStorage();
        // 如果有模块名 则删除模块下的属性信息 比如删除user下的username 使用clear(username,user)
        // 会先获取整个Storage的信息赋值给val 然后判断是否有模块名 有的话 则删除val[user][username] 没有模块名 则直接删除val[key]
        if(module_name){
            delete val[module_name][key];
        }
        else{
            delete val[key];
        }
        // 最后将数据进行更新
        this.setItem(val);
    }
}

4-9 接口错误拦截
axios是promise的语法 通过then接受返回值，通过catch捕获异常，finally是无论错误与否都会实现的部分
get请求需要加params，post请求不需要params
axios.all可以同时发很多个请求
vue-axios方便我们将作用域挂载到vue实例上，方便我们去用this调用，不需要每个页面都导入axios插件 使用Vue.use(VueAxios,axios)将axios对象挂载到vue实例上 然后可以通过this.axios的方式使用axios
axios.interceptors接口拦截器

// 获取接口信息 所有接口的返回值都会经过response
axios.interceptors.response.use(function(response){
    // 请求成功时，我们只需要response.data的数据
    let res = response.data;
    // 判断状态码 0为请求成功
    if(res.status == 0){
        return res.data;
    }
    // 未登录时
    else if(res.status == 10)
    {
        window.location.href = '/#/login'
    }
    else{
        // res.msg是请求接口的错误信息
        alert(res.msg)
    }
});
// 根据前端跨域的方式做调整  /a/b : /api/a/b => /a/b
/* 
    如果前后端的地址都为同一个地址 则只需要设置成 /api
    如果前后端地址不一致，则需要写上完整的地址路径
*/
axios.defaults.baseURL = '/api';
// 设置超时时间 8000毫秒 = 8秒
axios.defaults.timeout = 8000; 

4-10 Mock设置(模拟数据)
开发阶段，为了高效率，需要提前Mock
减少代码的冗余、灵活插拔
减少沟通、减少接口联调时间、提高开发效率

方法:
1、本地创建json
静态加载json文件
this.axios.get('/mock/user/login.json').then((res)=>{
    this.res = res;
})

2、easy-mock平台
将axios.defaults.baseURL地址切换成 easy-mock平台上的项目URL即可
axios.defaults.baseURL = ' https://www.easy-mock.com/mock/5fbe0b3d1bc0682deacbfea7/mimall';
this.axios.get('/user/login').then((res)=>{
    this.res = res;
})

3、集成Mock API  与上两种方法的区别是Mock Api在请求之前就被拦截了 不会产生请求 但是可以看到数据
安装Mockjs cnpm i mockjs --save-dev将Mockjs写入package.json中
定义mock开关 
const mock = true;
if(mock){
    // import是预编译加载，require是从上到下执行的时候加载，如果代码在require前中止了 require不会运行
    require('./mock/api');
}
创建mock文件夹 api.js文件
import Mock from 'mockjs'
// 请求接口 是真实的接口 后期不用修改
this.axios.get('/user/login').then((res)=>{
    this.res = res;
})

5-1 Nav-Header
页面开始需要设置安全距离min-width 防止页面过小时被挤变形
sass预编译样式 可以利用变量的形式动态的实现CSS的样式 也便于修改

防止a标签刷新页面，可以给a标签去的href属性设置成javascript:;
设置style lang='scss' 通过@import 导入一个sass 可以实现样式嵌套
抽离container以便复用
设置margin-right:auto,margin-left:auto可以设置居中
height和line-height相同，可以使内容垂直居中
垂直居中: 设置flex布局，display:flex 两边对齐:justify-content:space-between; 水平方向居中:align-item:center; 

将a标签设置 display:inline-block; a标签是行内元素，与其它行内元素并排直到被挤满，才会到下一行，也不能设置宽、高，默认的宽高。
块级元素是霸占一行，不能与其他任何元素并列，能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。
块级元素有h1~h6, div, ul, li, ol, dl, dt, dd,form,p
行内元素有a,span,i,em,strong,b,label
而设置inline-block之后 将对象呈现成inline对象，但是对象内容是block对象呈现 就可以具有block的宽、高的同时还能有inline的同行特性
a标签的样式优先级大于父元素div的class样式优先级 在a标签中设置颜色才会生效

文本内容居中 text-align:center;

5-2 导航栏购物车
购物车的图标使用span标签 background:url('/imgs/icon-cart-checked.png') no repeat center; background-size:contain;(no repeat控制填充 center是居中 background-size:contain填充整个span) 还需要给span设置宽度 不然图标不会显示 先设置display:inline-block; width:16px;height:12px 

导航栏的图标 通过伪类的方法设置成两张图片 当鼠标悬停时会切换第二张图片 默认只显示第一张图片 类似轮播的效果 伪元素是通过样式来达到元素效果的，也就是说伪元素不占用dom元素节点，伪元素before和after属于行内元素
sass里面可以在标签内加入伪类 例如a{&:before{}} 
css中加入伪类的方式为 标签名::before{}
header-logo是可视化的区域 宽高为55px 为一张图片的宽高 用伪类的方式实现两张图片来回切换 a标签宽设置成110px 两张图片的宽度
&:before{content=' '} 必须要使用content=' '占位且设置宽高 不然显示不了
&:before{}利用伪类显示第一个图片 &:after{}显示第二张图片的内容
&:hover:before{margin:-55px transition:margin .2s} 控制margin值来回切换图片 transition通过margin改变控制过渡动画
transition使用过渡 第一个属性为需要过渡的元素 第二个属性是过渡时间

5-3 导航栏
导航栏搜索功能 使用<div class="wrapper"></div>将文本框和搜索图片图标包裹住 input标签 <input type='text' name='keyword'>实现文本框 
搜索图标用a标签实现 a{background:url('')}
通过设置wrapper的样式 
.wrapper
{
    display:flex;
    justify-content:space-between;
    align-item=center;
}实现文本框和图标垂直居中
.input{
    border:none;
    box-sizing:border-box; //不包括padding值
}
设置a标签的样式 和 购物车图标类似

mixin.scss 可以将变量抽取出来 甚至把样式定义成方法 提取公共部分
mixin定义:
@mixin flex($hov:space-between,$col:center){
    display:flex;
    justify-content:$hov;
    align-items:$col
}
hov和col都是变量 可以设置默认值 也可以不设置,在调用mixin时修改变量的值

mixin调用:
先@import 导入'mixin.scss'
在样式中调用mixin
@include flex(); // 括号里面可以修改变量的值 例如想要justify-content:center 可以使用@include flex(center)

5-4 导航栏下拉菜单
利用ul、li列表实现下拉菜单的内容 
下拉菜单内容包括 手机图片 手机名称 手机价格 点击内容需要跳转到产品详细页面 所以使用a标签实现
当鼠标没有悬停时,隐藏菜单 利用伪类&:hover{.children{height:220px; }} 设置鼠标悬停时的样式，这里设置高度 将高度展开 可以让隐藏的菜单显示
在父元素设置position:relative 子元素中设置position:absolute 可以使子元素相对于父元素进行定位 margin、padding值都是基于父元素的位置
产品列表有6个 可以使用float浮动 float:flex; width:16.6%; // 让图片在百分百的宽度中六等分
产品列表li标签中的pro-img、pro-name、pro-price的产品信息 可以直接在li标签样式中加入text-align:center 可以让文字图片居中

间隔线
在每个产品的中间加入一条线 不能够直接在li标签中加 因为中间的间隔线高度和整个li标签的高度不一样 所以可以使用&:before{}伪类的方法设置高度，利用absolute定位，还需要将li标签设置成position:relative相对定位，这样间隔线可以基于li标签进行定位，在每一个子元素中都可以出现,使用伪类还要注意要用content:' '进行占位 
由于不需要最后一个产品右边不需要间隔线 &:last-child:before{display:none;}即可 (意思为before元素的最后一个元素不显示)





